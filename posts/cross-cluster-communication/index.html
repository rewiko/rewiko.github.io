<!doctype html><html><head><title>Kubernetes Cross Cluster Communication</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><link rel=stylesheet href=/assets/css/bootstrap.min.css><link rel=stylesheet href=/assets/css/layouts/main.css><link rel=stylesheet href=/assets/css/style.css><link rel=stylesheet href=/assets/css/navigators/navbar.css><link href="https://fonts.googleapis.com/css2?family=Muli:wght@300;400;500;600" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css><link rel=icon type=image/png href=/images/site/favicon.png><link rel=stylesheet href=/assets/css/style.css><meta name=description content="Kubernetes Cross Cluster Communication"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/atom-one-dark.min.css><link rel=stylesheet href=/assets/css/layouts/single.css><link rel=stylesheet href=/assets/css/navigators/sidebar.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-4JC5W7WL97"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4JC5W7WL97",{anonymize_ip:!1})}</script></head><body data-spy=scroll data-target=#TableOfContents data-offset=80><div class="container-fluid bg-dimmed wrapper"><nav class="navbar navbar-expand-xl top-navbar final-navbar shadow"><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button onclick=toggleSidebar()>
<span class=navbar-toggler-icon></span></button>
<a class=navbar-brand href=/><img src=/images/site/main-logo.png>Anthony Comtois' Blog</a>
<button class="navbar-toggler navbar-light" id=toc-toggler type=button onclick=toggleTOC()>
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse lang-selector" id=top-nav-items><ul class="navbar-nav ml-auto"></ul></div></div><img src=/images/site/main-logo.png class=d-none id=main-logo>
<img src=/images/site/inverted-logo.png class=d-none id=inverted-logo></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><input type=text placeholder=Search data-search id=search-box><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/posts data-filter=all>Posts</a></li><div class=subtree><li><a href=/posts/introduction/>Introduction</a></li><li><a href=/posts/kubernetes-network-policies/kubernetesnetworkpolicies/>Kubernetes Network Policies - Cilium</a></li><li><a class=active href=/posts/cross-cluster-communication/>Kubernetes Cross Cluster Communication</a></li><li><a href=/posts/kubecon-ebpf-cilium-at-sky/>Kubecon EBPF & Cilium at Sky Presentation</a></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class=content><div class="container p-0 read-area"><div class="hero-area col-sm-12" id=hero-area style=background-image:url(https://rewiko.github.io/posts/introduction/Rainbow-Vortex.svg)></div><div class=page-content><div class="author-profile ml-auto align-self-lg-center"><img class=rounded-circle src=/images/author/anthony.png><h5 class=author-name>Anthony Comtois</h5><p>September 1, 2021</p></div><div class=title><h1>Kubernetes Cross Cluster Communication</h1></div><div class=post-content id=post-content><h2 id=kubernetes-cross-cluster-communication>Kubernetes Cross Cluster Communication</h2><p>Depending on your requirements and needs, you might not need cross cluster communication at the pod level.</p><p>In most cases, stateless components are running within your cluster and talking to some stateful components like databases which are running outside of the cluster. This is a common approach right now because it is still very difficult to run stateful components on a kubernetes cluster even if some solutions exist like statefulsets which add ordering and stable dns for your pods.</p><p>However managing stateful components is a bit more involved than just running a statefulset, you will need:</p><ul><li>a dynamic configuration of your container to define how to join a existing cluster</li><li>automated backup</li><li>the ability to execute some maintenance tasks like the cassandra repair process, etcd defragmentation</li><li>a replication in place across two clusters to handle load, failover due to network issue, or disruptive change which hopefully should not happen often</li></ul><p>Stateful applications are starting to be deployed on top of kubernetes with the help of kubernetes operators easing the management of those components.</p><p>For example: ElasticSearch, Postgres and Cassandra/Scylladb have their own operator to be able to create a cluster, manage the data backup and restoration, handle upgrades..</p><p>These operators extend kubernetes by creating some Custom Resources Definition (defining the schema of a kubernetes object) and Custom Resources (an actual kubernetes similar to the core kubernetes resources: deployments, statefulsets..).</p><p>By default your pods will be able to talk inside the same cluster, however you might be interested in a stateful database spreaded across 2 clusters.</p><p>For example a cassandra cluster with some pods in cluster A and some others in cluster B, they will need to talk between each other which include routing and service discovery between 2 pods in different clusters.</p><p>Ideally all those stateful components should have their data replicated into the other Kubernetes cluster which might be located into another region.</p><p>In that case, I will talk about 2 Kubernetes clusters located in different regions and different cloud providers.</p><p>The first one cluster A will be located in AWS eu-west-1, the latter cluster B on GCP europe-west4-c.</p><p>In order to connect components you will need connectivity to pods between cluster A and B and a way to discover the ips of the cluster located in the other region, also called service discovery.</p><h2 id=cross-cluster-connectivity>Cross cluster connectivity</h2><h3 id=non-overlapping-ip-range>Non overlapping ip range</h3><p>It is essential to not have overlapping ip range while trying to communicate between different clusters.
In this scenario, ip range allocated into those 2 clusters connect overlap which means cluster A cannot use some ips on cluster B otherwise the router will not forward the packet correctly and will stay within the VPC.</p><h3 id=using-an-overlay>Using an overlay</h3><p>You can use an overlay network for example calico and connect the 2 clusters with calico reflectors.
However it can be difficult to run calico reflector on GKE or any managed cluster, because the underlying network can change based on the provider&rsquo;s decision.</p><p>There are multiple downsides of those solutions but they can be a good fit based on your requirements:</p><ul><li>On managed kubernetes like GKE, EKS, AKS you might not have control over the kubernetes nodes network.
For example, it can be complicated to run calico and the route reflector on top of GKE, you will be dependent on GKE network change which might affect the overlay.</li><li>Network performance can be affected while using an overlay as it will need to encapsulate the network packet within a UDP packet which introduces some overhead.</li></ul><h3 id=using-native-routing>Using native routing</h3><p>A better solution would be to use the native routing solution depending on your provider, eg: GKE native routing, AWS-cni for AWS/EKS, Azure cni.. using the native network performance of the underlying provider.</p><p>By having those native routing capabilities, all pods will interact directly with the network stack of your VPC and route table. Therefore you can connect different clusters using transit gateway or VPC peering if both clusters are located on AWS. In our case we would like to connect an AWS cluster to a GKE cluster, we can rely on the Cloud VPN solution to connect AWS and GCP. When the network is established you will only need to update your route table to forward the ip range of the other cluster into the VPN tunnel.</p><h2 id=service-discovery>Service discovery</h2><p>When pod to pod connectivity has been achieved, ideally you should rely on a service discovery mechanism to retrieve dynamically the list of peers to communicate with them and join the cluster.</p><h3 id=using-consul>Using consul</h3><p>Consul permits to register services and can be connected across multiple clusters.</p><p>This can be a viable solution but you need to take in consideration the overhead of managing another component on top of Kubernetes.</p><h3 id=using-coredns>Using CoreDNS</h3><h4 id=kubernetai-plugin>Kubernetai plugin</h4><p>CoreDNS is now the default DNS server deployed within the cluster. By default it will resolve a single cluster watching the apiservers to get the mapping between hostname and ips.</p><p><a href=https://github.com/coredns/kubernetai>Kubernetai</a> is a plugin which will allow to communicate with multiple apiservers and get the informations of multiples clusters.</p><p>The default kubernetes domain is <code>svc.cluster.local</code>, you can add 2 others domain one per region:</p><ul><li><code>svc.aws-euwest1.local</code></li><li><code>svc.gcp-europe-west4-c.local</code></li></ul><p>Any pod on the cluster will be able to resolve headless service to get the pod ips associated with a statefulset.</p><h4 id=network-load-balancer--dns-forwarding>Network Load Balancer + DNS forwarding</h4><p>Another way would be to create a network load balancer pointing to CoreDNS service foreach region and update CoreDNS to forward dns query to the other cluster for a specific domain.</p><p>Useful link:</p><ul><li><a href="https://www.cockroachlabs.com/docs/stable/orchestrate-cockroachdb-with-kubernetes-multi-cluster.html?filters=eks">https://www.cockroachlabs.com/docs/stable/orchestrate-cockroachdb-with-kubernetes-multi-cluster.html?filters=eks</a></li></ul><h2 id=service-mesh-routing>Service mesh routing</h2><h3 id=istiolinkerd-cross-cluster>Istio/Linkerd cross cluster</h3><p>Service meshes like Istio or Linkerd allow cross cluster routing via their gateway which has the full network knowledge of both clusters. Service mesh brings a lot of extra feature like mutualTLS, improve load balancing feature (circuit breaker, A/B testing) and observability (distributed tracing, sidecar metrics).
Service mesh will need a complete blog post to explain all those features.</p><p>Useful links:</p><ul><li><a href=https://istio.io/latest/docs/setup/install/multicluster/>https://istio.io/latest/docs/setup/install/multicluster/</a></li><li><a href=https://linkerd.io/2.10/features/multicluster/>https://linkerd.io/2.10/features/multicluster/</a></li></ul><h3 id=cilium-cross-cluster-routing>Cilium cross cluster routing</h3><p>Cilium mesh will allow you to send traffic to pods behind a service to different clusters. The cluster ip will be different on each cluster but the list of pod ips will be the all pods available on the cluster.</p><p>Useful links:</p><ul><li><a href=https://cilium.io/blog/2019/03/12/clustermesh>https://cilium.io/blog/2019/03/12/clustermesh</a></li><li><a href=https://docs.cilium.io/en/v1.9/gettingstarted/clustermesh/>https://docs.cilium.io/en/v1.9/gettingstarted/clustermesh/</a></li></ul><h2 id=conclusion>Conclusion</h2><p>For now, there is no recommended or standard way to provide routing and service discovery across Kubernetes clusters.</p><p>It will depend on your requirements, using direct routing and CoreDNS/Kubernetai might be good enough to connect your different stateful components.</p><p>In this case, the headless service (SRV record) will be provided to the kubernetes operator. The latter will get the hostname associated and update the config of the component (eg: cassandra).</p><p>Relying on Istio/Linkerd or Cilium to provide cross-cluster routing and service discovery can also be a good approach for stateless services.</p></div><hr><div class="row next-prev-navigator"><div class="col-md-6 previous-article"><a href=/posts/kubernetes-network-policies/kubernetesnetworkpolicies/ title="Kubernetes Network Policies - Cilium & EBPF" class="btn btn-outline-info"><div><i class="fas fa-chevron-circle-left"></i> Prev</div><div class=next-prev-text>Kubernetes Network Policies - Cilium & EBPF</div></a></div><div class="col-md-6 next-article"><a href=/posts/kubecon-ebpf-cilium-at-sky/ title="Kubecon EBPF & Cilium at Sky Presentation" class="btn btn-outline-info"><div>Next <i class="fas fa-chevron-circle-right"></i></div><div class=next-prev-text>Kubecon EBPF & Cilium at Sky Presentation</div></a></div></div><hr><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="anthonycomtoisblog",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></section><section class=toc-section id=toc-section><div class=toc-holder><h5 class="text-center pl-3">Table of Contents</h5><hr><div class=toc><nav id=TableOfContents><ul><li><a href=#kubernetes-cross-cluster-communication>Kubernetes Cross Cluster Communication</a></li><li><a href=#cross-cluster-connectivity>Cross cluster connectivity</a><ul><li><a href=#non-overlapping-ip-range>Non overlapping ip range</a></li><li><a href=#using-an-overlay>Using an overlay</a></li><li><a href=#using-native-routing>Using native routing</a></li></ul></li><li><a href=#service-discovery>Service discovery</a><ul><li><a href=#using-consul>Using consul</a></li><li><a href=#using-coredns>Using CoreDNS</a><ul><li><a href=#kubernetai-plugin>Kubernetai plugin</a></li><li><a href=#network-load-balancer--dns-forwarding>Network Load Balancer + DNS forwarding</a></li></ul></li></ul></li><li><a href=#service-mesh-routing>Service mesh routing</a><ul><li><a href=#istiolinkerd-cross-cluster>Istio/Linkerd cross cluster</a></li><li><a href=#cilium-cross-cluster-routing>Cilium cross cluster routing</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></div></section></div><footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-left"><div class="col-md-4 col-sm-12"><h5>Navigation</h5><ul><li class=nav-item><a class=smooth-scroll href=/#about>About</a></li><li class=nav-item><a class=smooth-scroll href=/#skills>Skills</a></li><li class=nav-item><a class=smooth-scroll href=/#experiences>Experiences</a></li><li class=nav-item><a class=smooth-scroll href=/#projects>Projects</a></li><li class=nav-item><a class=smooth-scroll href=/#recent-posts>Recent Posts</a></li></ul></div><div class="col-md-4 col-sm-12"><h5>Contact me:</h5><ul><li><span>Email:</span> <span><a href=mailto:anthony.comtois@gmail.com target=/>anthony.comtois@gmail.com <i class="fas fa-envelope"></i></a></span></li><li><span>Linkedin:</span> <span><a href=https://www.linkedin.com/in/anthony-comtois-574a5551/>Anthony Comtois <i class="fab fa-linkedin"></i></a></span></li></ul></div></div></div><hr><div class=container><div class=row><div class=col-md-4><a href=https://github.com/rewiko/ target=/>My contributions <i class="fab fa-github"></i></a></div><div class=col-md-4>© Anthony Comtois. All rights reserved. 2020</div><div class=col-md-4><a href=https://twitter.com/rewiko/ target=/>Follow me on <i class="fab fa-twitter"></i> </a>,
<a href=/posts/index.xml target=/>RSS <i class="fas fa-rss-square"></i></a></a></div></div></div></footer><script src=/assets/js/jquery-3.4.1.min.js></script>
<script src=/assets/js/popper.min.js></script>
<script src=/assets/js/bootstrap.min.js></script>
<script src=/assets/js/navbar.js></script>
<script src=/assets/js/main.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js></script>
<script src=/assets/js/single.js></script>
<script>hljs.initHighlightingOnLoad()</script></body></html>